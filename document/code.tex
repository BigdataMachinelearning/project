\chapter{Base}
\section{Base.h}
\begin{enumerate}
\item void Sum(const VVReal \&, VReal*);
\end{enumerate}
\section{random.h}

\begin{enumerate}
\item void UniformSample(int t, VInt* v);
\\sample between 0 and size(v) uniformly t times.
\end{enumerate}

\section{stl\_util.h}
\begin{enumerate}
\item void Multiply(const VReal \&src, double m, VReal* des);
\item void Multiply(const VVReal \&src, double m, VVReal* des);
\item int DiffNum(const VInt \&lhs, const VInt \&rhs);
\\ the number of different value between lhs and rhs
\item double Max(const T \&data);
\item void Push(int num, const E \&e, C* des);
\end{enumerate}

\section{probability.h}
\begin{enumerate}
\item int SumTopN(const VInt \&src, int len);
\item bool NextMultiSeq(int num, VInt* des);
\\ 产生下一个多项式分布的序列
\item bool NextBinarySeq(VInt* des);
\\ 产生下一个二进制的序列
\end{enumerate}

\section{io\_util.h}
\begin{enumerate}
\item void ReadFileToStr(const Str \&file, Str* str);
\item void ReadFileToStr(const Str \&file, const Str \&del, VStr* data);
\item Str ReadFileToStr(const Str \&file);
\item void WriteStrToFile(const Str \&str, const Str \&file);
\item void ReadFile(const Str \&file, VInt* des);
\item void WriteFile(const Str \&file, const VInt \&data);
\end{enumerate}

\section{stat.h}
\begin{enumerate}
\item double LogSum(double log\_a, double log\_b);
\item double LogSum(const VReal \&data);
\\LogSum函数可以在求配分函数的时候用，很多时候势函数由于很
大造成溢出，采用取对数的方法可以防止溢出。
\end{enumerate}
